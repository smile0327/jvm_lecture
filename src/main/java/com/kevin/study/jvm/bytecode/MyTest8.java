package com.kevin.study.jvm.bytecode;

/**
 * @Auther: kevin
 * @Description:
 *  现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。
 *
 *  所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行该指令。
 *  所谓编译执行，就是通过即时编译器（Just In Time, JIT）将字节码转换为本地机器码来执行；现代JVM会根据代码热点来
 *  生成相应的本地机器码。
 *
 *  基于栈的指令集与基于寄存器的指令集之间的关系：
 *  1、JVM执行指令时所采取的方式是基于栈的指令集；
 *  2、基于栈的指令集主要的操作有入栈与出栈两种；
 *  3、基于栈的指令集的优势在于它可以在不同平台之间移植，而基于寄存器的指令集是与硬件架构紧密关联的，无法做到可移植；
 *  4、基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中
 *     完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓冲区中进行执行的，速度要快很多。虽然虚拟机可以
 *     采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。
 *
 * @Company: 上海博般数据技术有限公司
 * @Version: 1.0.0
 * @Date: Created in 10:02 2020/8/17
 * @ProjectName: jvm_lecture
 */
public class MyTest8 {

    public int myCalculate(){
        int a = 1;
        int b = 2;
        int c = 3;
        int d = 4;

        int result = (a + b - c) * d;
        return result;
    }
}

/*
 0 iconst_1     // push 常数1 到操作数栈顶
 1 istore_1     // 将操作数栈顶的值弹出，并写入到局部变量表中索引为1 的位置设置为栈顶的值
 2 iconst_2     // 将数值2 推到操作数栈顶
 3 istore_2     // 将操作数栈顶的值弹出，并写入到局部变量表中索引为2 的位置设置为栈顶的值
 4 iconst_3     // 将数值3 推到操作数栈顶
 5 istore_3     // 将操作数栈顶的值弹出，并写入到局部变量表中索引为3 的位置设置为栈顶的值
 6 iconst_4     // 将数值4 推到操作数栈顶
 7 istore 4     // 将操作数栈顶的值弹出，并写入到局部变量表中索引为4 的位置设置为栈顶的值（istore_n只到3了，这里的4是参数传入，意思都一样）
 9 iload_1      // 将局部变量表中索引为1 的位置的值推到操作数栈顶
10 iload_2      // 将局部变量表中索引为2 的位置的值推到操作数栈顶
11 iadd         // 将栈顶和栈顶下面的一个元素（必须是int类型）弹出，并做加法，然后将结果写入到栈顶
12 iload_3      // 将局部变量表中索引为3 的位置的值推到操作数栈顶
13 isub         // 将栈顶和栈顶下面的一个元素（必须是int类型）弹出，用栈顶下面的元素减去栈顶的值，并将结果写入到栈顶
14 iload 4      // 将局部变量表中索引为4 的位置的值推到操作数栈顶
16 imul         // 将栈顶和扎你当下面的一个元素（必须是int类型）弹出，计算两个数的乘积，并将结果写入到栈顶
17 istore 5     // 将操作数栈顶的值弹出，并写入到局部变量表中索引为5 的位置设置为栈顶的值
19 iload 5      // 将局部变量表中索引为5 的位置的值推到操作数栈顶
21 ireturn      // 从操作数栈中弹出返回结果（如果没有抛出异常）
 */